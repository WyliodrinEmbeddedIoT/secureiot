<!DOCTYPE html>
<html>
  <head>
    <title>Day 1 - Tock</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../style/style.css"></link>
    <style>
      
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Introduction to Tock

.small[.center[![Introduction to Tock](../images/rust_tock_embedded.svg)]]

.left[
Alexandru Radovici, ilustrations by [Mieuneli](http://miau.laura.ro)
]

---

# Development Environment

You will have to install:
- [Visual Studio Code](https://code.visualstudio.com/) - a powerfull source code editor 
    - [RLS](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust) - the Rust extension
    - [Remote SSH](https://code.visualstudio.com/docs/remote/ssh-tutorial) - the connection to the virtual machine

- [VirtualBox](https://www.virtualbox.org/) - a Linux environment&sup1; with the Tock setup
  - [Extension Pack](https://download.virtualbox.org/virtualbox/6.1.18/Oracle_VM_VirtualBox_Extension_Pack-6.1.18.vbox-extpack) - you will be able to see you USB devices in guest virtual machine

- [Tock Virtual Machine](https://epitechfr.sharepoint.com/sites/DevelopingSecureEmbeddedSystemsUsingtheRustProgrammingLangua/Documents%20partages/General/Virtual%20Machine/Tock.ova) - Import Appliance
    - Windows: Make sure you select __Allow__ when you get a question from the Firewall

&sup1;If you are running Linux or MacOS, this step is recommended, not necessary.<br>

---
## Virtual Box

1. Install the [Extension Pack](https://download.virtualbox.org/virtualbox/6.1.18/Oracle_VM_VirtualBox_Extension_Pack-6.1.18.vbox-extpack)
2. Import Appliance [Tock](https://epitechfr.sharepoint.com/sites/DevelopingSecureEmbeddedSystemsUsingtheRustProgrammingLangua/Documents%20partages/General/Virtual%20Machine/Tock.ova)



---
## Visual Studio Code

Setup the Extensions:
  - [RLS](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust) - the Rust extension
  - [Remote SSH](https://code.visualstudio.com/docs/remote/ssh-tutorial) - the connection to the virtual machine

.center[.title[![Remote SHH Link](../images/vscode_ssh.png)]]

---

### SSH connect

1. Start the Virtual Machine with Tock
2. Connect to host: `tock@localhost:2000`&sup1; (password: `tock`)

.center[.title[![Remote SHH Link](../images/vscode_ssh_link.png)]]

&sup1; Due to an issue with the Remote SSH Extension, you might always have to write `tock@localhost:2000`, it will not be remebered.


---

class: split-50
# BBC Micro:bit v2

.column[
- __nRF52833__ MCU 
- __512 Kbyte Flash__
- __128 Kbytes__ of __RAM__
- On-board __DAPLink SWD debugger__
- 25 LED matrix
- 2 buttons
- Motion sensor
- Temperature sensor
- BLE
]

.column[
.large_vertical[.center[![Data Types](../images/microbit-v2.png)]]
]

---

# Connect the board

Steps to connect the board

1. Connect the Micro:bit v2 (the board) to your computer
2. Connect the USB to the Virtual Machine (VM)
3. Check that the VM can access the USB

Upload the Tock kernel to the board

---

## 1. Connect Micro:bit v2 (the board)

Use the micro USB port

.title[.center[![Stack](../images/connect_microbit.jpg)]]

---
## 2. Connect the USB to the Virtual Machine

- The VM window has some buttons at the bottom, click the USB
- Select the option with `ARM "BBC micro:Bit CMSIS-DAP"`...&sup1; &sup2;

.screenshot[.center[![Stack](../images/vm_microbit.png)]]

&sup1; If it does not show up, make sure you have the [Extension Pack](https://download.virtualbox.org/virtualbox/6.1.18/Oracle_VM_VirtualBox_Extension_Pack-6.1.18.vbox-extpack) installed  
&sup2; The name can be different
---
## 3. Check that the VM can access the USB

In the VS Code shell, run

```bash
tock@tock:~/tock$ sudo dmesg
# this should output
   ...
   [   66.309735] usb 2-2: new full-speed USB device number 3 using ohci-pci
   [   66.842194] usb 2-2: New USB device found, idVendor=0d28, idProduct=0204, bcdDevice=10.00
   [   66.842197] usb 2-2: New USB device strings: Mfr=1, Product=2, SerialNumber=3
   [   66.842199] usb 2-2: Product: "BBC micro:bit CMSIS-DAP"
   [   66.842200] usb 2-2: Manufacturer: ARM
   [   66.842201] usb 2-2: SerialNumber: 9904360254174e45002a000f00000011000000009796990b
   [   66.876204] hid-generic 0003:0D28:0204.0002: hiddev0,hidraw1: USB HID v1.00 Device [ARM "BBC micro:bit CMSIS-DAP"] on usb-0000:00:06.0-2/input3
   [   66.905202] usb-storage 2-2:1.0: USB Mass Storage device detected
   [   66.910692] scsi host2: usb-storage 2-2:1.0
   [   66.910754] usbcore: registered new interface driver usb-storage
   [   66.911898] cdc_acm 2-2:1.1: ttyACM0: USB ACM device
   [   66.915832] usbcore: registered new interface driver cdc_acm
   [   66.915833] cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters
   [   66.916392] usbcore: registered new interface driver uas
   [   67.947927] scsi 2:0:0:0: Direct-Access     MBED     VFS              0.1  PQ: 0 ANSI: 2
   [   67.949409] sd 2:0:0:0: Attached scsi generic sg2 type 0
   [   67.963978] sd 2:0:0:0: [sdb] 131200 512-byte logical blocks: (67.2 MB/64.1 MiB)
   [   67.973825] sd 2:0:0:0: [sdb] Write Protect is off
   [   67.973829] sd 2:0:0:0: [sdb] Mode Sense: 03 00 00 00
   [   67.983491] sd 2:0:0:0: [sdb] No Caching mode page found
   [   67.983534] sd 2:0:0:0: [sdb] Assuming drive cache: write through
   [   68.060963]  sdb:
   [   68.116122] sd 2:0:0:0: [sdb] Attached SCSI removable disk
```

You should see something similar, search for __ttyACM0__&sup1;

&sup1; The name can be different, like ttyACM1 or ttyACM2

---
# Tock

- A <b>preemptive</b> embedded OS (runs on MCUs)
  - Cortex-M
  - RISC-V
- Uses memory protection (MPU required)
- Has separate <b>kernel and user space</b>
  - most embedded OS have the one piece software philosophy
- Runs untrusted apps in user space
- <b>Microkernel</b> architecture
- Kernel (and drivers) written in Rust
- Apps written in C/C++ or Rust (any language that can be compiled)

.right[![Tock](../images/tock.svg)]

---

# Tock Stack

.splash[.center[![Stack](../images/tock-stack.png)]]

Image from https://github.com/tock/tock/tree/master/doc.

---

# Let's write some code for Tock

In `/home/tock` you have:
```bash
+-- tock                # kernel
+-- libtock-c           # C userspace
```

.card[.small[.center[![Tock Stack](../images/sep_stack.png)]]]

---
class: split-50
# A few words about how ARM-Cortex M boots

.column[
### Exceptions
- Reset
- Supervisor
- SysTick 
- Pending SV
- Faults

### Interrupts
- Events from hardware
]

.column[
.large_vertical[.center[![Interrupts](../images/cortex-m4-vectors.png)]]
]

---
# A few words about how Tock boots

In `/home/tock` you have:
```bash
+-- tock            # kernel
|   +-- arch            # code specific to MCUs (ARM, RISC-V)
|   +-- boards          # code specific to boards (Micro:bit v2)
|   +-- capsules        # drivers
|   +-- chips           # code specific to MCUs (STM32F412G, E310, )
|   +-- doc             # documentation
|   +-- kernel          # actual kernel (scheduler, ipc, memory)
|   +-- libraries       # libraries used by all the source code
|   +-- tools           # scripts for testing on other tools
|   +-- vagrant         # VM setup (different from ours)
```

.small[![Source Dependencies](../images/source_dependencies.svg)]

---

## Uploading software

 1. _Flashing_ - using a debugger
 2. _Programming_ - using a bootloader

.center[.title[![Flash](../images/flash.svg)]]

---

## Uploading Tock

Tock is composed out of two separate parts that have to be uploaded separately:
 1. Kernel - the actual system
   - uploaded using `openocd` (`make flash`)
 2. Applications
   - TBF files
   - more than one
   - uploaded using `tockloader`

---

# Build and upload the kernel

The kernel folder is called `tock`.

In `boards/microbit_v2` run:

```bash
tock@tock:~/tock/boards/microbit_v2$ make flash
   Compiling tock-tbf v0.1.0 (/home/tock/tock/libraries/tock-tbf)
   Compiling tock-cells v0.1.0 (/home/tock/tock/libraries/tock-cells)
   Compiling tock-registers v0.6.0 (/home/tock/tock/libraries/tock-register-interface)
   Compiling enum_primitive v0.1.0 (/home/tock/tock/libraries/enum_primitive)
   Compiling tickv v0.1.0 (/home/tock/tock/libraries/tickv)
   Compiling microbit_v2 v0.1.0 (/home/tock/tock/boards/microbit_v2)
   Compiling kernel v0.1.0 (/home/tock/tock/kernel)
   Compiling cortexm v0.1.0 (/home/tock/tock/arch/cortex-m)
   Compiling nrf5x v0.1.0 (/home/tock/tock/chips/nrf5x)
   Compiling capsules v0.1.0 (/home/tock/tock/capsules)
   Compiling cortexm4 v0.1.0 (/home/tock/tock/arch/cortex-m4)
   Compiling components v0.1.0 (/home/tock/tock/boards/components)
   Compiling nrf52 v0.1.0 (/home/tock/tock/chips/nrf52)
   Compiling nrf52_components v0.1.0 (/home/tock/tock/boards/nordic/nrf52_components)
   Compiling nrf52833 v0.1.0 (/home/tock/tock/chips/nrf52833)
    Finished release [optimized + debuginfo] target(s) in 30.63s
   text    data     bss     dec     hex filename
 106497       0   16384  122881   1e001 /home/tock/tock/target/thumbv7em-none-eabi/release/microbit_v2
openocd -f openocd.cfg -c "program /home/tock/tock/target/thumbv7em-none-eabi/release/microbit_v2.elf; verify_image /home/tock/tock/target/thumbv7em-none-eabi/release/microbit_v2.elf; reset; shutdown;"
Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
adapter speed: 10000 kHz
cortex_m reset_config sysresetreq
Info : CMSIS-DAP: SWD  Supported
Info : CMSIS-DAP: Interface Initialised (SWD)
Info : CMSIS-DAP: FW Version = 0255
Info : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 0 TDO = 0 nTRST = 0 nRESET = 1
Info : CMSIS-DAP: Interface ready
Info : reduce speed request: 10000kHz to 5000kHz maximum
Info : clock speed 10000 kHz
Info : SWD DPIDR 0x2ba01477
Info : nrf52.cpu: hardware has 6 breakpoints, 4 watchpoints
target halted due to debug-request, current mode: Thread 
xPSR: 0x01000000 pc: 0x00007c5c msp: 0x20001000
** Programming Started **
auto erase enabled
Warn : Unknown device (HWID 0x00000197)
Info : Padding image section 1 with 155648 bytes
Warn : using fast async flash loader. This is currently supported
Warn : only with ST-Link and CMSIS-DAP. If you have issues, add
Warn : "set WORKAREASIZE 0" before sourcing nrf51.cfg to disable it
wrote 266240 bytes from file /home/tock/tock/target/thumbv7em-none-eabi/release/microbit_v2.elf in 25.410511s (10.232 KiB/s)
** Programming Finished **
verified 106497 bytes in 1.220209s (85.232 KiB/s)
shutdown command invoked
```

Now you have a running Tock kernel

---

## Access the board

Use the serial port via `tockloader`

Hint: open a new terminal in VS Code and keep it open

```bash
tock@tock:~$ tockloader listen
[INFO   ] No device name specified. Using default name "tock".
[INFO   ] No serial port with device name "tock" found.
[INFO   ] Found 1 serial port.
[INFO   ] Using "/dev/ttyACM0 - "BBC micro:bit CMSIS-DAP" - mbed Serial Port".
[INFO   ] Listening for serial output.
Initialization complete. Entering main loop.
```

Reset the board.

---

## Workpoint 1 .top_image[![Work In Progress](../images/work_in_progress.png)]

Upload the kernel _without a bootloader_&sup1;. In `main.rs`, find the line that prints the start message, and write a message of your own.

```bash
Initialization complete. Entering main loop
```

Example

```bash
Welcome from Tock
```

.center[.card[.small_vertical[![Data Types](../images/sep_reset_handler.png)]]]

&sup1; Hint: read `layout.ld`

---

## Workpoint 2 .top_image[![Work In Progress](../images/work_in_progress.png)]

The board provides a process console in the serial line. Type `help` in tockloader and try to use the console.

How many processes do you have right now?

---

# A few words about C applications

In `/home/tock` you have:
```bash
+-- libtock-c     # user space
|   +-- doc             # documentation
|   +-- examples        # example applications
|   |   +-- c_hello         # hello world 
|   |   +-- blink           # LED blink
|   |   +-- buttons         # bnutton events
|   |   |   ...  
|   |   |-- <your app>      # your applications
|   +-- libc++          # C++ libraries
|   +-- lua53           # Lua Language library
|   +-- lvgl            # Little vGL UI library
|   +-- newlib          # C library
|   ...
|   +-- tools           # tools for building
```

- just copy `c_hello` and start working on the new application
- the name of an application is its folder name

---
## Build an application

Open `tock/libtock-c` in VS Code  
In a shell, run:

```bash
tock@tock-dev:~/tock/libtock-c$ cd examples/c_hello
tock@tock:~/libtock-c/examples/c_hello$ make
 DIR        ../../libtock/build/cortex-m0
  CC        ../../libtock/internal/alarm_internal.c
  CC        ../../libtock/internal/nonvolatile_storage_internal.c
  CC        ../../libtock/ieee802154.c
  CC        ../../libtock/alarm_timer.c
  CC        ../../libtock/i2c_master_slave.c
  CC        ../../libtock/spi.c
  CC        ../../libtock/max17205.c
  CC        ../../libtock/nrf51_serialization.c
  CC        ../../libtock/humidity.c
  CC        ../../libtock/gpio_async.c
  CC        ../../libtock/crc.c
  CC        ../../libtock/tock.c
  CC        ../../libtock/lps25hb.c
  CC        ../../libtock/dac.c
  CC        ../../libtock/buzzer.c
  CC        ../../libtock/rng.c
  CC        ../../libtock/l3gd20.c
  CC        ../../libtock/ninedof.c
  CC        ../../libtock/screen.c
  CC        ../../libtock/crt0.c
  CC        ../../libtock/proximity.c
  CC        ../../libtock/app_state.c
  CC        ../../libtock/console.c
  CC        ../../libtock/lsm303dlhc.c
  CC        ../../libtock/ipc.c
  CC        ../../libtock/gpio.c
  CC        ../../libtock/ltc294x.c
  CC        ../../libtock/pca9544a.c
  CC        ../../libtock/i2c_master.c
  CC        ../../libtock/unit_test.c
  CC        ../../libtock/analog_comparator.c
  CC        ../../libtock/sound_pressure.c
  CC        ../../libtock/led.c
  CC        ../../libtock/ble.c
  CC        ../../libtock/sys.c
  CC        ../../libtock/spi_peripheral.c
  CC        ../../libtock/temperature.c
  CC        ../../libtock/touch.c
  CC        ../../libtock/udp.c
  CC        ../../libtock/tsl2561.c
  CC        ../../libtock/usb.c
  CC        ../../libtock/sdcard.c
  CC        ../../libtock/ambient_light.c
  CC        ../../libtock/button.c
  CC        ../../libtock/adc.c
  CC        ../../libtock/text_screen.c
  AR        ../../libtock/build/cortex-m0/libtock.a
 DIR        ../../libtock/build/cortex-m3
  CC        ../../libtock/internal/alarm_internal.c
  CC        ../../libtock/internal/nonvolatile_storage_internal.c
  CC        ../../libtock/ieee802154.c
  CC        ../../libtock/alarm_timer.c
  CC        ../../libtock/i2c_master_slave.c
  CC        ../../libtock/spi.c
  CC        ../../libtock/max17205.c
  CC        ../../libtock/nrf51_serialization.c
  CC        ../../libtock/humidity.c
  CC        ../../libtock/gpio_async.c
  CC        ../../libtock/crc.c
  CC        ../../libtock/tock.c
  CC        ../../libtock/lps25hb.c
  CC        ../../libtock/dac.c
  CC        ../../libtock/buzzer.c
  CC        ../../libtock/rng.c
  CC        ../../libtock/l3gd20.c
  CC        ../../libtock/ninedof.c
  CC        ../../libtock/screen.c
  CC        ../../libtock/crt0.c
  CC        ../../libtock/proximity.c
  CC        ../../libtock/app_state.c
  CC        ../../libtock/console.c
  CC        ../../libtock/lsm303dlhc.c
  CC        ../../libtock/ipc.c
  CC        ../../libtock/gpio.c
  CC        ../../libtock/ltc294x.c
  CC        ../../libtock/pca9544a.c
  CC        ../../libtock/i2c_master.c
  CC        ../../libtock/unit_test.c
  CC        ../../libtock/analog_comparator.c
  CC        ../../libtock/sound_pressure.c
  CC        ../../libtock/led.c
  CC        ../../libtock/ble.c
  CC        ../../libtock/sys.c
  CC        ../../libtock/spi_peripheral.c
  CC        ../../libtock/temperature.c
  CC        ../../libtock/touch.c
  CC        ../../libtock/udp.c
  CC        ../../libtock/tsl2561.c
  CC        ../../libtock/usb.c
  CC        ../../libtock/sdcard.c
  CC        ../../libtock/ambient_light.c
  CC        ../../libtock/button.c
  CC        ../../libtock/adc.c
  CC        ../../libtock/text_screen.c
  AR        ../../libtock/build/cortex-m3/libtock.a
 DIR        ../../libtock/build/cortex-m4
  CC        ../../libtock/internal/alarm_internal.c
  CC        ../../libtock/internal/nonvolatile_storage_internal.c
  CC        ../../libtock/ieee802154.c
  CC        ../../libtock/alarm_timer.c
  CC        ../../libtock/i2c_master_slave.c
  CC        ../../libtock/spi.c
  CC        ../../libtock/max17205.c
  CC        ../../libtock/nrf51_serialization.c
  CC        ../../libtock/humidity.c
  CC        ../../libtock/gpio_async.c
  CC        ../../libtock/crc.c
  CC        ../../libtock/tock.c
  CC        ../../libtock/lps25hb.c
  CC        ../../libtock/dac.c
  CC        ../../libtock/buzzer.c
  CC        ../../libtock/rng.c
  CC        ../../libtock/l3gd20.c
  CC        ../../libtock/ninedof.c
  CC        ../../libtock/screen.c
  CC        ../../libtock/crt0.c
  CC        ../../libtock/proximity.c
  CC        ../../libtock/app_state.c
  CC        ../../libtock/console.c
  CC        ../../libtock/lsm303dlhc.c
  CC        ../../libtock/ipc.c
  CC        ../../libtock/gpio.c
  CC        ../../libtock/ltc294x.c
  CC        ../../libtock/pca9544a.c
  CC        ../../libtock/i2c_master.c
  CC        ../../libtock/unit_test.c
  CC        ../../libtock/analog_comparator.c
  CC        ../../libtock/sound_pressure.c
  CC        ../../libtock/led.c
  CC        ../../libtock/ble.c
  CC        ../../libtock/sys.c
  CC        ../../libtock/spi_peripheral.c
  CC        ../../libtock/temperature.c
  CC        ../../libtock/touch.c
  CC        ../../libtock/udp.c
  CC        ../../libtock/tsl2561.c
  CC        ../../libtock/usb.c
  CC        ../../libtock/sdcard.c
  CC        ../../libtock/ambient_light.c
  CC        ../../libtock/button.c
  CC        ../../libtock/adc.c
  CC        ../../libtock/text_screen.c
  AR        ../../libtock/build/cortex-m4/libtock.a
 DIR        ../../libtock/build/cortex-m7
  CC        ../../libtock/internal/alarm_internal.c
  CC        ../../libtock/internal/nonvolatile_storage_internal.c
  CC        ../../libtock/ieee802154.c
  CC        ../../libtock/alarm_timer.c
  CC        ../../libtock/i2c_master_slave.c
  CC        ../../libtock/spi.c
  CC        ../../libtock/max17205.c
  CC        ../../libtock/nrf51_serialization.c
  CC        ../../libtock/humidity.c
  CC        ../../libtock/gpio_async.c
  CC        ../../libtock/crc.c
  CC        ../../libtock/tock.c
  CC        ../../libtock/lps25hb.c
  CC        ../../libtock/dac.c
  CC        ../../libtock/buzzer.c
  CC        ../../libtock/rng.c
  CC        ../../libtock/l3gd20.c
  CC        ../../libtock/ninedof.c
  CC        ../../libtock/screen.c
  CC        ../../libtock/crt0.c
  CC        ../../libtock/proximity.c
  CC        ../../libtock/app_state.c
  CC        ../../libtock/console.c
  CC        ../../libtock/lsm303dlhc.c
  CC        ../../libtock/ipc.c
  CC        ../../libtock/gpio.c
  CC        ../../libtock/ltc294x.c
  CC        ../../libtock/pca9544a.c
  CC        ../../libtock/i2c_master.c
  CC        ../../libtock/unit_test.c
  CC        ../../libtock/analog_comparator.c
  CC        ../../libtock/sound_pressure.c
  CC        ../../libtock/led.c
  CC        ../../libtock/ble.c
  CC        ../../libtock/sys.c
  CC        ../../libtock/spi_peripheral.c
  CC        ../../libtock/temperature.c
  CC        ../../libtock/touch.c
  CC        ../../libtock/udp.c
  CC        ../../libtock/tsl2561.c
  CC        ../../libtock/usb.c
  CC        ../../libtock/sdcard.c
  CC        ../../libtock/ambient_light.c
  CC        ../../libtock/button.c
  CC        ../../libtock/adc.c
  CC        ../../libtock/text_screen.c
  AR        ../../libtock/build/cortex-m7/libtock.a
 DIR        build/cortex-m0
  CC        main.c
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
  LD        build/cortex-m0/cortex-m0.elf
 DIR        build/cortex-m3
  CC        main.c
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
  LD        build/cortex-m3/cortex-m3.elf
 DIR        build/cortex-m4
  CC        main.c
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
  LD        build/cortex-m4/cortex-m4.elf
 DIR        build/cortex-m7
  CC        main.c
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
  LD        build/cortex-m7/cortex-m7.elf
Application size report for target cortex-m0:
   text    data     bss     dec     hex filename
    848     208    2396    3452     d7c build/cortex-m0/cortex-m0.elf
Application size report for target cortex-m3:
   text    data     bss     dec     hex filename
    848     208    2396    3452     d7c build/cortex-m3/cortex-m3.elf
Application size report for target cortex-m4:
   text    data     bss     dec     hex filename
    848     208    2396    3452     d7c build/cortex-m4/cortex-m4.elf
Application size report for target cortex-m7:
   text    data     bss     dec     hex filename
    848     208    2396    3452     d7c build/cortex-m7/cortex-m7.elf
```

It compiles the applications for ARM-Cortex M0, M3, M4 and M7.

All the versions are bundled into a TAB file in `build/c_hello.tab`.

---
## Upload an application

You will need [tockloader](https://github.com/tock/tockloader).
  - display board information (apps, kernel etc)
  - install apps
  - delete apps

```bash
tock@tock:~/libtock-c/examples/c_hello$ tockloader 
[ERROR  ] Missing Command.

usage: tockloader [-h] [--debug] [--version]  ...

optional arguments:
  -h, --help         show this help message and exit
  --debug            Print additional debugging information
  --version          Print Tockloader version and exit

Commands:
  
    listen           Open a terminal to receive UART data
    install          Install apps on the board
    update           Update an existing app with this version
    uninstall        Remove an already flashed app
    list             List the apps installed on the board
    info             Verbose information about the connected board
    erase-apps       Delete apps from the board
    enable-app       Enable an app so the kernel runs it
    disable-app      Disable an app so it will not be started
    sticky-app       Make an app sticky so it is hard to erase
    unsticky-app     Make an app unsticky (the normal setting)
    flash            Flash binaries to the chip
    read             Read arbitrary flash memory
    write            Write arbitrary flash memory with constant value
    dump-flash-page  Read a page of flash from the board
    list-attributes  List attributes stored on the board
    set-attribute    Store attribute on the board
    remove-attribute
                     Remove attribute from the board
    set-start-address
                     Set bootloader jump address
    inspect-tab      Get details about a TAB
    list-known-boards
                     List the boards that Tockloader explicitly knows about
```

---

### Tockloader for microbit_v2

Tockloader uses `openocd` to read and write to the micro:bit v2. 

You have to add two parameters to the command line:
  - `--board microbit_v2`
  - `--openocd`

Parameters are placed after the command.

```bash
$ tockloader command --board microbit_v2 --openocd ...
```

---

### Tockloader examples

List applications

```bash
tock@tock:~/libtock-c/examples/c_hello$ tockloader list --board microbit_v2 --openocd[INFO   ] Using settings from KNOWN_BOARDS["microbit_v2"]
┌──────────────────────────────────────────────────┐
│ App 0                                            |
└──────────────────────────────────────────────────┘
  Name:                  c_hello
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   2048 bytes


[INFO   ] Finished in 1.484 seconds
```

Install an application

```bash
tock@tock:~/libtock-c/examples/c_hello$ tockloader install --board microbit_v2 --openocd build/c_hello.tab 
[INFO   ] Using settings from KNOWN_BOARDS["microbit_v2"]
[STATUS ] Installing app on the board...
[INFO   ] Flashing app c_hello binary to board.
[INFO   ] Finished in 4.699 seconds
```

---

# Workpoint 3 .top_image[![Work In Progress](../images/work_in_progress.png)]

1. Upload the `c_hello` app.
2. Upload the `blink` app.
3. Use the process console to list the processes

---

# Workpoint 4 .top_image[![Work In Progress](../images/work_in_progress.png)]

Write and upload a new application that writes a message to the console using `printf`.

```c
#include <stdio.h>

int main (void)
{
    printf ("Application Message\n");
    return 0;
}
```

Hint: You can start by copying one of the existing applications.

---

# Workpoint 5 .top_image[![Work In Progress](../images/work_in_progress.png)]

1. Change the `blink` application so that:
    - it prints to the console the number of available LEDs
    - it lights up one LED at a time

2. Change the `button` application so that:
    - it prints the number of buttons available
    - it prints the name of the button (A or B) that was pressed

Hint: use `printf` to write to the console (just as you would use it normally)

---

# Workpoint 6 .top_image[![Work In Progress](../images/work_in_progress.png)]

Change the `button` application so that:
  - it prints on the LED matrix the name of the pressed button
  - waits a few seconds and stops printing

Hint: you will have to write your own small font for the A and B letters

---

# Workpoint 7 .top_image[![Work In Progress](../images/work_in_progress.png)]

1. Upload the sensors app and find out what sensors are available
2. Write your own weather station app the print in the console the sensor data once a second
3. Use the LED matrix to print the temperature

Hint: you will have to write your own small font for numbers


---
## Workpoint 8 .top_image[![Work In Progress](../images/work_in_progress.png)]

Enable the system calls trace in `kernel/src/config.rs`. 
1. Upload an app that prints a text on the shell using `printf`. 
  - How many system calls is printf using?
  - What is the driver number of the driver used for printing?

2. Upload the blink app and look at the system calls trace.
  - What is the leds matrix's driver number?

---

## Workpoint 9 .top_image[![Work In Progress](../images/work_in_progress.png)]

1. Write and upload and app that faults.
```c
int main(void)
{
      int *s = NULL;
      *s = 0;
      return 0;
}
```

2. Modify the app fault policy so that it does not panic when an app faults
  - hint: `main.rs` serach for `FAULT_RESPONSE`.

---
# Hello Driver

Kernel

1. Write the `Hello` structure and its implementation
2. Implement the `Driver` trait for `Hello`
  - all methiods have default implementation
3. Add the driver to the board structure in `main.rs`

User space

- Implement the system calls

---
## Kernel

Write the driver and implement the `Driver` trait (1 and 2).

Write a file `hello.rs` in the same folder as `main.rs`.

```rust
use kernel::{Driver, ProcessId, CommandReturn, ErrorCode};

/// Each driver is identified by a unique number
///
/// numbers higher than 0xa0000000 are unused by standard drivers
pub const DRIVER_NUM: usize = 0xa0000000;

/// The Hello structure
pub struct Hello {}


/// The hello implementation
impl Hello {
    pub fn new() -> Hello {
        Hello {}
    }
}

/// The driver system calls implementation
impl Driver for Hello {
    /// subscribe and allow will use the default implementation

    /// command syscall
    fn command(&self, command_num: usize, r2: usize, r3: usize, caller_id: ProcessId) -> CommandReturn {
        match command_num {
            // command_num 0 is used to verify if the driver exists
            0 => CommandReturn::success(),

            // the command number is not defined
            _ => CommandReturn::failure (ErrorCode::NOSUPPORT),
        }
    }
}
```

---
### Kernel

Register the driver for in the board's structure (3)

In `main.rs` 

```rust
/// use the driver module
mod hello;

// ...
/// Supported drivers by the platform
pub struct Platform {
    ble_radio: &'static capsules::ble_advertising_driver::BLE<
        'static,
        nrf52::ble_radio::Radio<'static>,
        capsules::virtual_alarm::VirtualMuxAlarm<'static, nrf52::rtc::Rtc<'static>>,
    >,
    console: &'static capsules::console::Console<'static>,
    gpio: &'static capsules::gpio::GPIO<'static, nrf52::gpio::GPIOPin<'static>>,
    led: &'static capsules::led_matrix::LedMatrixDriver<
        'static,
        nrf52::gpio::GPIOPin<'static>,
        capsules::virtual_alarm::VirtualMuxAlarm<'static, nrf52::rtc::Rtc<'static>>,
    >,
    button: &'static capsules::button::Button<'static, nrf52::gpio::GPIOPin<'static>>,
    rng: &'static capsules::rng::RngDriver<'static>,
    ninedof: &'static capsules::ninedof::NineDof<'static>,
    lsm303agr: &'static capsules::lsm303agr::Lsm303agrI2C<'static>,
    temperature: &'static capsules::temperature::TemperatureSensor<'static>,
    ipc: kernel::ipc::IPC<NUM_PROCS>,
    adc: &'static capsules::adc::AdcVirtualized<'static>,
    alarm: &'static capsules::alarm::AlarmDriver<
        'static,
        capsules::virtual_alarm::VirtualMuxAlarm<'static, nrf52::rtc::Rtc<'static>>,
    >,
    buzzer: &'static capsules::buzzer_driver::Buzzer<
        'static,
        capsules::virtual_alarm::VirtualMuxAlarm<'static, nrf52833::rtc::Rtc<'static>>,
    >,
    app_flash: &'static capsules::app_flash_driver::AppFlash<'static>,
    sound_pressure: &'static capsules::sound_pressure::SoundPressureSensor<'static>,
    // hello driver
    hello: &'static hello::Hello
}
// ...

/// Mapping of integer syscalls to objects that implement syscalls.
impl kernel::Platform for Platform {
  fn with_driver<F, R>(&self, driver_num: usize, f: F) -> R
  where
      F: FnOnce(Option<&dyn kernel::Driver>) -> R,
  {
      match driver_num {
          capsules::console::DRIVER_NUM => f(Some(self.console)),
          capsules::gpio::DRIVER_NUM => f(Some(self.gpio)),
          capsules::alarm::DRIVER_NUM => f(Some(self.alarm)),
          capsules::button::DRIVER_NUM => f(Some(self.button)),
          capsules::led_matrix::DRIVER_NUM => f(Some(self.led)),
          capsules::ninedof::DRIVER_NUM => f(Some(self.ninedof)),
          capsules::adc::DRIVER_NUM => f(Some(self.adc)),
          capsules::temperature::DRIVER_NUM => f(Some(self.temperature)),
          capsules::lsm303agr::DRIVER_NUM => f(Some(self.lsm303agr)),
          capsules::rng::DRIVER_NUM => f(Some(self.rng)),
          capsules::ble_advertising_driver::DRIVER_NUM => f(Some(self.ble_radio)),
          capsules::buzzer_driver::DRIVER_NUM => f(Some(self.buzzer)),
          capsules::app_flash_driver::DRIVER_NUM => f(Some(self.app_flash)),
          capsules::sound_pressure::DRIVER_NUM => f(Some(self.sound_pressure)),
          kernel::ipc::DRIVER_NUM => f(Some(&self.ipc)),
          // hello driver
          hello::DRIVER_NUM => f(Some(self.hello)),
          _ => f(None),
      }
  }
}
// ...

/// Main function called after RAM initialized.
#[no_mangle]
pub unsafe fn main() {
    // ...

    /// Create a new instance of type Hello using Hello::new ()
    let hello = static_init! (hello::Hello, hello::Hello::new());

    /// Create a new instance of the board's structure
    let platform = Platform {
      ble_radio: ble_radio,
      console: console,
      gpio: gpio,
      button: button,
      led: led,
      rng: rng,
      temperature: temperature,
      lsm303agr: lsm303agr,
      ninedof: ninedof,
      buzzer: buzzer,
      sound_pressure: sound_pressure,
      adc: adc_syscall,
      alarm: alarm,
      app_flash: app_flash,
      ipc: kernel::ipc::IPC::new(board_kernel, &memory_allocation_capability),
      // the hello driver
      hello: hello,
  }
    // ...
}
```

---
## User space

In your application's folder

hello.h
```c
#pargma once

#define HELLO_DRIVER_NUMBER 0xa0000000

bool hello_is_available (void);

```

hello.c
```c
#include "hello.h"
#include <tock.h>

bool hello_is_available (void) {
    syscall_return_t command_return = command(HELLO_DRIVER_NUMBER, 0, 0, 0);
    if (command_return.type == TOCK_SYSCALL_SUCCESS) {
        return true;
    } else {
        return false;
    }
}
```

---
## Workpoint 10 .top_image[![Work In Progress](../images/work_in_progress.png)]

Add `command_num` 1 to the driver and print a text on the shell when it is called.

```rust
/// The driver system calls implementation
impl Driver for Hello {
    /// subscribe and allow will use the default implementation

    /// command syscall
    fn command(&self, command_num: usize, r2: usize, r3: usize, caller_id: ProcessId) -> CommandReturn {
      match command_num {
          // command_num 0 is used to verify if the driver exists
          0 => CommandReturn::success(),
          1 => // ...

          // the command number is not defined
          _ => CommandReturn::failure (ErrorCode::NOSUPPORT),
      }
  }
}
```

Add a function for it in the header and source file in userspace. 
Write and upload an app that userspace the driver.

---
# Mutability

All Tock traits use `&self` to be able to share a driver with several other drivers.

Interior mutability:
- Cell<T> (`core::cell::Cell`)
- OptionalCell<T> (`kernel::common:cells::OptionalCell`)
- TakeCell<T> (`kernel::common::cells::TakeCell`)

.right[
.card[.small_vertical[![Cell](../images/sep_cell.png)]]
.card[.small_vertical[![OptionalCell](../images/sep_optionalcell.png)]]
.card[.small_vertical[![TakeCell](../images/sep_takecell.png)]]
]

---
## Workpoint 11 .top_image[![Work In Progress](../images/work_in_progress.png)]

Add `command_num` 2 that will increment a counter and return it to the app.
  Hint: use `CommandReturn::success_u32 (...)`

Each time the app calls the system call, the driver will will return an incremented number.

```c
#include "hello.c"
#include <stdio.h>
#include <timer.h>

int nr;

int main(void) {
    while (true) {
        nr = hello_counter ();
        printf ("Counter %d\n", n);
        delay_ms (1000);
    }
}
```

Hint: store the current number in the `Hello` structure.

---
# Lunch work .top_image[![Work In Progress](../images/work_in_progress.png)]

Work in teams

- Write a driver that exposes thew following commands:
  1. Set the latitude and longitude parameters
  2. Set the acceleration value
  3. Set the temperature value
  4. Set the sound value
  5. Print in JSON format all the values to the console
  6. Print in XML format all the values to the console

- Write a software in any language you want that reads the JSON or XML from the console and sends it
to an MQTT broker. You may use the free version of [HiveMQ](https://www.hivemq.com/mqtt-cloud-broker).

- Use [Node-Red](https://nodered.org/) ([Frontend for Node-Red](https://fred.sensetecnic.com/) provides a free hosted version) to read the data from the MQTT broker and plot it on a world map.
Hint: use the `WorldMap` node.

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script src="../script/playground.js">
    </script>
    <script>
      var slideshow = remark.create({
		navigation: {
				scroll: false
			}
    });
    window.cPlaygroundUrl = "https://cplayground.com/";
    window.playgroundUrl = "https://play.rust-lang.org/";
    </script>
  </body>
</html>