<!DOCTYPE html>
<html>
  <head>
    <title>Day 1 - Tock</title>
    <meta charset="utf-8">
    <link rel="stylesheet" href="../style/style.css"></link>
    <style>
      
    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Introduction to Tock

.small[.center[![Introduction to Tock](../images/rust_tock_embedded.svg)]]

.left[
Alexandru Radovici, ilustrations by [Mieuneli](http://miau.laura.ro)
]

---

# Development Environment

You will have to install:
- [Visual Studio Code](https://code.visualstudio.com/) - a powerfull source code editor 
    - [RLS](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust) - the Rust extension
    - [Remote SSH](https://code.visualstudio.com/docs/remote/ssh-tutorial) - the connection to the virtual machine

- [VirtualBox](https://www.virtualbox.org/) - a Linux environment&sup1; with the Tock setup
  - [Extension Pack](https://download.virtualbox.org/virtualbox/6.1.18/Oracle_VM_VirtualBox_Extension_Pack-6.1.18.vbox-extpack) - you will be able to see you USB devices in guest virtual machine

- [Tock Virtual Machine](https://epitechfr.sharepoint.com/sites/DevelopingSecureEmbeddedSystemsUsingtheRustProgrammingLangua/Documents%20partages/General/Virtual%20Machine/Tock.ova) - Import Appliance
    - Windows: Make sure you select __Allow__ when you get a question from the Firewall

&sup1;If you are running Linux or MacOS, this step is recommended, not necessary.<br>

---
## Virtual Box

1. Install the [Extension Pack](https://download.virtualbox.org/virtualbox/6.1.18/Oracle_VM_VirtualBox_Extension_Pack-6.1.18.vbox-extpack)
2. Import Appliance [Tock](https://epitechfr.sharepoint.com/sites/DevelopingSecureEmbeddedSystemsUsingtheRustProgrammingLangua/Documents%20partages/General/Virtual%20Machine/Tock.ova)



---
## Visual Studio Code

Setup the Extensions:
  - [RLS](https://marketplace.visualstudio.com/items?itemName=rust-lang.rust) - the Rust extension
  - [Remote SSH](https://code.visualstudio.com/docs/remote/ssh-tutorial) - the connection to the virtual machine

.center[.title[![Remote SHH Link](../images/vscode_ssh.png)]]

---

### SSH connect

1. Start the Virtual Machine with Tock
2. Connect to host: `tock@localhost:2000`&sup1; (password: `tock`)

.center[.title[![Remote SHH Link](../images/vscode_ssh_link.png)]]

&sup1; Due to an issue with the Remote SSH Extension, you might always have to write `tock@localhost:2000`, it will not be remebered.


---

class: split-50
# BBC Micro:bit v2

.column[
- __nRF52833__ MCU 
- __512 Kbyte Flash__
- __128 Kbytes__ of __RAM__
- On-board __DAPLink SWD debugger__
- 25 LED matrix
- 2 buttons
- Motion sensor
- Temperature sensor
- BLE
]

.column[
.large_vertical[.center[![Data Types](../images/microbit-v2.png)]]
]

---

# Connect the board

Steps to connect the board

1. Connect the Micro:bit v2 (the board) to your computer
2. Connect the USB to the Virtual Machine (VM)
3. Check that the VM can access the USB

Upload the Tock kernel to the board

---

## 1. Connect Micro:bit v2 (the board)

Use the micro USB port

.title[.center[![Stack](../images/connect_microbit.jpg)]]

---
## 2. Connect the USB to the Virtual Machine

TODO

- The VM window has some buttons at the bottom, click the USB
- Select the option with `BBC Micro:Bit v2`...&sup1; &sup2;

.screenshot[.center[![Stack](../images/vm_stm.png)]]

&sup1; If it does not show up, make sure you have the [Extension Pack](https://download.virtualbox.org/virtualbox/6.1.18/Oracle_VM_VirtualBox_Extension_Pack-6.1.18.vbox-extpack) installed  
&sup2; The name can be different
---
## 3. Check that the VM can access the USB

In the VS Code shell, run

```bash
tock@tock:~/tock$ sudo dmesg
# this should output
   ...
   [   66.309735] usb 2-2: new full-speed USB device number 3 using ohci-pci
   [   66.842194] usb 2-2: New USB device found, idVendor=0d28, idProduct=0204, bcdDevice=10.00
   [   66.842197] usb 2-2: New USB device strings: Mfr=1, Product=2, SerialNumber=3
   [   66.842199] usb 2-2: Product: "BBC micro:bit CMSIS-DAP"
   [   66.842200] usb 2-2: Manufacturer: ARM
   [   66.842201] usb 2-2: SerialNumber: 9904360254174e45002a000f00000011000000009796990b
   [   66.876204] hid-generic 0003:0D28:0204.0002: hiddev0,hidraw1: USB HID v1.00 Device [ARM "BBC micro:bit CMSIS-DAP"] on usb-0000:00:06.0-2/input3
   [   66.905202] usb-storage 2-2:1.0: USB Mass Storage device detected
   [   66.910692] scsi host2: usb-storage 2-2:1.0
   [   66.910754] usbcore: registered new interface driver usb-storage
   [   66.911898] cdc_acm 2-2:1.1: ttyACM0: USB ACM device
   [   66.915832] usbcore: registered new interface driver cdc_acm
   [   66.915833] cdc_acm: USB Abstract Control Model driver for USB modems and ISDN adapters
   [   66.916392] usbcore: registered new interface driver uas
   [   67.947927] scsi 2:0:0:0: Direct-Access     MBED     VFS              0.1  PQ: 0 ANSI: 2
   [   67.949409] sd 2:0:0:0: Attached scsi generic sg2 type 0
   [   67.963978] sd 2:0:0:0: [sdb] 131200 512-byte logical blocks: (67.2 MB/64.1 MiB)
   [   67.973825] sd 2:0:0:0: [sdb] Write Protect is off
   [   67.973829] sd 2:0:0:0: [sdb] Mode Sense: 03 00 00 00
   [   67.983491] sd 2:0:0:0: [sdb] No Caching mode page found
   [   67.983534] sd 2:0:0:0: [sdb] Assuming drive cache: write through
   [   68.060963]  sdb:
   [   68.116122] sd 2:0:0:0: [sdb] Attached SCSI removable disk
```

You should see something similar, search for __ttyACM0__&sup1;

&sup1; The name can be different, like ttyACM1 or ttyACM2

---
# Tock

- A <b>preemptive</b> embedded OS (runs on MCUs)
  - Cortex-M
  - RISC-V
- Uses memory protection (MPU required)
- Has separate <b>kernel and user space</b>
  - most embedded OS have the one piece software philosophy
- Runs untrusted apps in user space
- <b>Microkernel</b> architecture
- Kernel (and drivers) written in Rust
- Apps written in C/C++ or Rust (any language that can be compiled)

.right[![Tock](../images/tock.svg)]

---

# Tock Stack

.splash[.center[![Stack](../images/tock-stack.png)]]

Image from https://github.com/tock/tock/tree/master/doc.

---

# Let's write some code for Tock

In `/home/tock` you have:
```bash
+-- tock                # kernel
+-- libtock-c           # C userspace
```

.card[.small[.center[![Tock Stack](../images/sep_stack.png)]]]

---
class: split-50
# A few words about how ARM-Cortex M boots

.column[
### Exceptions
- Reset
- Supervisor
- SysTick 
- Pending SV
- Faults

### Interrupts
- Events from hardware
]

.column[
.large_vertical[.center[![Interrupts](../images/cortex-m4-vectors.png)]]
]

---
# A few words about how Tock boots

In `/home/tock` you have:
```bash
+-- tock            # kernel
|   +-- arch            # code specific to MCUs (ARM, RISC-V)
|   +-- boards          # code specific to boards (Micro:bit v2)
|   +-- capsules        # drivers
|   +-- chips           # code specific to MCUs (STM32F412G, E310, )
|   +-- doc             # documentation
|   +-- kernel          # actual kernel (scheduler, ipc, memory)
|   +-- libraries       # libraries used by all the source code
|   +-- tools           # scripts for testing on other tools
|   +-- vagrant         # VM setup (different from ours)
```

.small[![Source Dependencies](../images/source_dependencies.svg)]

---

## Uploading software

 1. _Flashing_ - using a debugger
 2. _Programming_ - using a bootloader

.center[.title[![Flash](../images/flash.svg)]]

---

## Uploading Tock

Tock is composed out of two separate parts that have to be uploaded separately:
 1. Kernel - the actual system
   - uploaded using `openocd` (`make flash`)
 2. Applications
   - TBF files
   - more than one
   - uploaded using `tockloader`

---

# Build and upload the kernel

The kernel folder is called `tock`.

In `boards/microbit_v2` run:

```bash
tock@tock:~/tock/boards/microbit_v2$ make flash
   Compiling tock-tbf v0.1.0 (/home/tock/tock/libraries/tock-tbf)
   Compiling tock-cells v0.1.0 (/home/tock/tock/libraries/tock-cells)
   Compiling tock-registers v0.6.0 (/home/tock/tock/libraries/tock-register-interface)
   Compiling enum_primitive v0.1.0 (/home/tock/tock/libraries/enum_primitive)
   Compiling tickv v0.1.0 (/home/tock/tock/libraries/tickv)
   Compiling microbit_v2 v0.1.0 (/home/tock/tock/boards/microbit_v2)
   Compiling kernel v0.1.0 (/home/tock/tock/kernel)
   Compiling cortexm v0.1.0 (/home/tock/tock/arch/cortex-m)
   Compiling nrf5x v0.1.0 (/home/tock/tock/chips/nrf5x)
   Compiling capsules v0.1.0 (/home/tock/tock/capsules)
   Compiling cortexm4 v0.1.0 (/home/tock/tock/arch/cortex-m4)
   Compiling components v0.1.0 (/home/tock/tock/boards/components)
   Compiling nrf52 v0.1.0 (/home/tock/tock/chips/nrf52)
   Compiling nrf52_components v0.1.0 (/home/tock/tock/boards/nordic/nrf52_components)
   Compiling nrf52833 v0.1.0 (/home/tock/tock/chips/nrf52833)
    Finished release [optimized + debuginfo] target(s) in 30.63s
   text    data     bss     dec     hex filename
 106497       0   16384  122881   1e001 /home/tock/tock/target/thumbv7em-none-eabi/release/microbit_v2
openocd -f openocd.cfg -c "program /home/tock/tock/target/thumbv7em-none-eabi/release/microbit_v2.elf; verify_image /home/tock/tock/target/thumbv7em-none-eabi/release/microbit_v2.elf; reset; shutdown;"
Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
adapter speed: 10000 kHz
cortex_m reset_config sysresetreq
Info : CMSIS-DAP: SWD  Supported
Info : CMSIS-DAP: Interface Initialised (SWD)
Info : CMSIS-DAP: FW Version = 0255
Info : SWCLK/TCK = 1 SWDIO/TMS = 1 TDI = 0 TDO = 0 nTRST = 0 nRESET = 1
Info : CMSIS-DAP: Interface ready
Info : reduce speed request: 10000kHz to 5000kHz maximum
Info : clock speed 10000 kHz
Info : SWD DPIDR 0x2ba01477
Info : nrf52.cpu: hardware has 6 breakpoints, 4 watchpoints
target halted due to debug-request, current mode: Thread 
xPSR: 0x01000000 pc: 0x00007c5c msp: 0x20001000
** Programming Started **
auto erase enabled
Warn : Unknown device (HWID 0x00000197)
Info : Padding image section 1 with 155648 bytes
Warn : using fast async flash loader. This is currently supported
Warn : only with ST-Link and CMSIS-DAP. If you have issues, add
Warn : "set WORKAREASIZE 0" before sourcing nrf51.cfg to disable it
wrote 266240 bytes from file /home/tock/tock/target/thumbv7em-none-eabi/release/microbit_v2.elf in 25.410511s (10.232 KiB/s)
** Programming Finished **
verified 106497 bytes in 1.220209s (85.232 KiB/s)
shutdown command invoked
```

Now you have a running Tock kernel

---

## Access the board

Use the serial port via `tockloader`

Hint: open a new terminal in VS Code and keep it open

```bash
tock@tock:~$ tockloader listen
[INFO   ] No device name specified. Using default name "tock".
[INFO   ] No serial port with device name "tock" found.
[INFO   ] Found 1 serial port.
[INFO   ] Using "/dev/ttyACM0 - "BBC micro:bit CMSIS-DAP" - mbed Serial Port".
[INFO   ] Listening for serial output.
Initialization complete. Entering main loop.
```

Reset the board.

---

## Workpoint 1 .top_image[![Work In Progress](../images/work_in_progress.png)]

Upload the kernel _without a bootloader_&sup1;. In `main.rs`, find the line that prints the start message, and write a message of your own.

```bash
Initialization complete. Entering main loop
```

Example

```bash
Welcome from Tock
```

.center[.card[.small_vertical[![Data Types](../images/sep_reset_handler.png)]]]

&sup1; Hint: read `layout.ld`

---

## Workpoint 2 .top_image[![Work In Progress](../images/work_in_progress.png)]

The board provides a process console in the serial line. Type `help` in tockloader and try to use the console.

How many processes do you have right now?

---

# A few words about C applications

In `/home/tock` you have:
```bash
+-- libtock-c     # user space
|   +-- doc             # documentation
|   +-- examples        # example applications
|   |   +-- c_hello         # hello world 
|   |   +-- blink           # LED blink
|   |   +-- buttons         # bnutton events
|   |   |   ...  
|   |   |-- <your app>      # your applications
|   +-- libc++          # C++ libraries
|   +-- lua53           # Lua Language library
|   +-- lvgl            # Little vGL UI library
|   +-- newlib          # C library
|   ...
|   +-- tools           # tools for building
```

- just copy `c_hello` and start working on the new application
- the name of an application is its folder name

---
## Build an application

Open `tock/libtock-c` in VS Code  
In a shell, run:

```bash
tock@tock-dev:~/tock/libtock-c$ cd examples/c_hello
tock@tock:~/libtock-c/examples/c_hello$ make
 DIR        ../../libtock/build/cortex-m0
  CC        ../../libtock/internal/alarm_internal.c
  CC        ../../libtock/internal/nonvolatile_storage_internal.c
  CC        ../../libtock/ieee802154.c
  CC        ../../libtock/alarm_timer.c
  CC        ../../libtock/i2c_master_slave.c
  CC        ../../libtock/spi.c
  CC        ../../libtock/max17205.c
  CC        ../../libtock/nrf51_serialization.c
  CC        ../../libtock/humidity.c
  CC        ../../libtock/gpio_async.c
  CC        ../../libtock/crc.c
  CC        ../../libtock/tock.c
  CC        ../../libtock/lps25hb.c
  CC        ../../libtock/dac.c
  CC        ../../libtock/buzzer.c
  CC        ../../libtock/rng.c
  CC        ../../libtock/l3gd20.c
  CC        ../../libtock/ninedof.c
  CC        ../../libtock/screen.c
  CC        ../../libtock/crt0.c
  CC        ../../libtock/proximity.c
  CC        ../../libtock/app_state.c
  CC        ../../libtock/console.c
  CC        ../../libtock/lsm303dlhc.c
  CC        ../../libtock/ipc.c
  CC        ../../libtock/gpio.c
  CC        ../../libtock/ltc294x.c
  CC        ../../libtock/pca9544a.c
  CC        ../../libtock/i2c_master.c
  CC        ../../libtock/unit_test.c
  CC        ../../libtock/analog_comparator.c
  CC        ../../libtock/sound_pressure.c
  CC        ../../libtock/led.c
  CC        ../../libtock/ble.c
  CC        ../../libtock/sys.c
  CC        ../../libtock/spi_peripheral.c
  CC        ../../libtock/temperature.c
  CC        ../../libtock/touch.c
  CC        ../../libtock/udp.c
  CC        ../../libtock/tsl2561.c
  CC        ../../libtock/usb.c
  CC        ../../libtock/sdcard.c
  CC        ../../libtock/ambient_light.c
  CC        ../../libtock/button.c
  CC        ../../libtock/adc.c
  CC        ../../libtock/text_screen.c
  AR        ../../libtock/build/cortex-m0/libtock.a
 DIR        ../../libtock/build/cortex-m3
  CC        ../../libtock/internal/alarm_internal.c
  CC        ../../libtock/internal/nonvolatile_storage_internal.c
  CC        ../../libtock/ieee802154.c
  CC        ../../libtock/alarm_timer.c
  CC        ../../libtock/i2c_master_slave.c
  CC        ../../libtock/spi.c
  CC        ../../libtock/max17205.c
  CC        ../../libtock/nrf51_serialization.c
  CC        ../../libtock/humidity.c
  CC        ../../libtock/gpio_async.c
  CC        ../../libtock/crc.c
  CC        ../../libtock/tock.c
  CC        ../../libtock/lps25hb.c
  CC        ../../libtock/dac.c
  CC        ../../libtock/buzzer.c
  CC        ../../libtock/rng.c
  CC        ../../libtock/l3gd20.c
  CC        ../../libtock/ninedof.c
  CC        ../../libtock/screen.c
  CC        ../../libtock/crt0.c
  CC        ../../libtock/proximity.c
  CC        ../../libtock/app_state.c
  CC        ../../libtock/console.c
  CC        ../../libtock/lsm303dlhc.c
  CC        ../../libtock/ipc.c
  CC        ../../libtock/gpio.c
  CC        ../../libtock/ltc294x.c
  CC        ../../libtock/pca9544a.c
  CC        ../../libtock/i2c_master.c
  CC        ../../libtock/unit_test.c
  CC        ../../libtock/analog_comparator.c
  CC        ../../libtock/sound_pressure.c
  CC        ../../libtock/led.c
  CC        ../../libtock/ble.c
  CC        ../../libtock/sys.c
  CC        ../../libtock/spi_peripheral.c
  CC        ../../libtock/temperature.c
  CC        ../../libtock/touch.c
  CC        ../../libtock/udp.c
  CC        ../../libtock/tsl2561.c
  CC        ../../libtock/usb.c
  CC        ../../libtock/sdcard.c
  CC        ../../libtock/ambient_light.c
  CC        ../../libtock/button.c
  CC        ../../libtock/adc.c
  CC        ../../libtock/text_screen.c
  AR        ../../libtock/build/cortex-m3/libtock.a
 DIR        ../../libtock/build/cortex-m4
  CC        ../../libtock/internal/alarm_internal.c
  CC        ../../libtock/internal/nonvolatile_storage_internal.c
  CC        ../../libtock/ieee802154.c
  CC        ../../libtock/alarm_timer.c
  CC        ../../libtock/i2c_master_slave.c
  CC        ../../libtock/spi.c
  CC        ../../libtock/max17205.c
  CC        ../../libtock/nrf51_serialization.c
  CC        ../../libtock/humidity.c
  CC        ../../libtock/gpio_async.c
  CC        ../../libtock/crc.c
  CC        ../../libtock/tock.c
  CC        ../../libtock/lps25hb.c
  CC        ../../libtock/dac.c
  CC        ../../libtock/buzzer.c
  CC        ../../libtock/rng.c
  CC        ../../libtock/l3gd20.c
  CC        ../../libtock/ninedof.c
  CC        ../../libtock/screen.c
  CC        ../../libtock/crt0.c
  CC        ../../libtock/proximity.c
  CC        ../../libtock/app_state.c
  CC        ../../libtock/console.c
  CC        ../../libtock/lsm303dlhc.c
  CC        ../../libtock/ipc.c
  CC        ../../libtock/gpio.c
  CC        ../../libtock/ltc294x.c
  CC        ../../libtock/pca9544a.c
  CC        ../../libtock/i2c_master.c
  CC        ../../libtock/unit_test.c
  CC        ../../libtock/analog_comparator.c
  CC        ../../libtock/sound_pressure.c
  CC        ../../libtock/led.c
  CC        ../../libtock/ble.c
  CC        ../../libtock/sys.c
  CC        ../../libtock/spi_peripheral.c
  CC        ../../libtock/temperature.c
  CC        ../../libtock/touch.c
  CC        ../../libtock/udp.c
  CC        ../../libtock/tsl2561.c
  CC        ../../libtock/usb.c
  CC        ../../libtock/sdcard.c
  CC        ../../libtock/ambient_light.c
  CC        ../../libtock/button.c
  CC        ../../libtock/adc.c
  CC        ../../libtock/text_screen.c
  AR        ../../libtock/build/cortex-m4/libtock.a
 DIR        ../../libtock/build/cortex-m7
  CC        ../../libtock/internal/alarm_internal.c
  CC        ../../libtock/internal/nonvolatile_storage_internal.c
  CC        ../../libtock/ieee802154.c
  CC        ../../libtock/alarm_timer.c
  CC        ../../libtock/i2c_master_slave.c
  CC        ../../libtock/spi.c
  CC        ../../libtock/max17205.c
  CC        ../../libtock/nrf51_serialization.c
  CC        ../../libtock/humidity.c
  CC        ../../libtock/gpio_async.c
  CC        ../../libtock/crc.c
  CC        ../../libtock/tock.c
  CC        ../../libtock/lps25hb.c
  CC        ../../libtock/dac.c
  CC        ../../libtock/buzzer.c
  CC        ../../libtock/rng.c
  CC        ../../libtock/l3gd20.c
  CC        ../../libtock/ninedof.c
  CC        ../../libtock/screen.c
  CC        ../../libtock/crt0.c
  CC        ../../libtock/proximity.c
  CC        ../../libtock/app_state.c
  CC        ../../libtock/console.c
  CC        ../../libtock/lsm303dlhc.c
  CC        ../../libtock/ipc.c
  CC        ../../libtock/gpio.c
  CC        ../../libtock/ltc294x.c
  CC        ../../libtock/pca9544a.c
  CC        ../../libtock/i2c_master.c
  CC        ../../libtock/unit_test.c
  CC        ../../libtock/analog_comparator.c
  CC        ../../libtock/sound_pressure.c
  CC        ../../libtock/led.c
  CC        ../../libtock/ble.c
  CC        ../../libtock/sys.c
  CC        ../../libtock/spi_peripheral.c
  CC        ../../libtock/temperature.c
  CC        ../../libtock/touch.c
  CC        ../../libtock/udp.c
  CC        ../../libtock/tsl2561.c
  CC        ../../libtock/usb.c
  CC        ../../libtock/sdcard.c
  CC        ../../libtock/ambient_light.c
  CC        ../../libtock/button.c
  CC        ../../libtock/adc.c
  CC        ../../libtock/text_screen.c
  AR        ../../libtock/build/cortex-m7/libtock.a
 DIR        build/cortex-m0
  CC        main.c
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
  LD        build/cortex-m0/cortex-m0.elf
 DIR        build/cortex-m3
  CC        main.c
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
  LD        build/cortex-m3/cortex-m3.elf
 DIR        build/cortex-m4
  CC        main.c
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
  LD        build/cortex-m4/cortex-m4.elf
 DIR        build/cortex-m7
  CC        main.c
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
perl: warning: Setting locale failed.
perl: warning: Please check that your locale settings:
        LANGUAGE = (unset),
        LC_ALL = (unset),
        LC_TIME = "ro_RO.UTF-8",
        LC_MONETARY = "ro_RO.UTF-8",
        LC_ADDRESS = "ro_RO.UTF-8",
        LC_TELEPHONE = "ro_RO.UTF-8",
        LC_NAME = "ro_RO.UTF-8",
        LC_MEASUREMENT = "ro_RO.UTF-8",
        LC_IDENTIFICATION = "ro_RO.UTF-8",
        LC_NUMERIC = "ro_RO.UTF-8",
        LC_PAPER = "ro_RO.UTF-8",
        LANG = "en_US.UTF-8"
    are supported and installed on your system.
perl: warning: Falling back to a fallback locale ("en_US.UTF-8").
  LD        build/cortex-m7/cortex-m7.elf
Application size report for target cortex-m0:
   text    data     bss     dec     hex filename
    848     208    2396    3452     d7c build/cortex-m0/cortex-m0.elf
Application size report for target cortex-m3:
   text    data     bss     dec     hex filename
    848     208    2396    3452     d7c build/cortex-m3/cortex-m3.elf
Application size report for target cortex-m4:
   text    data     bss     dec     hex filename
    848     208    2396    3452     d7c build/cortex-m4/cortex-m4.elf
Application size report for target cortex-m7:
   text    data     bss     dec     hex filename
    848     208    2396    3452     d7c build/cortex-m7/cortex-m7.elf
```

It compiles the applications for ARM-Cortex M0, M3, M4 and M7.

All the versions are bundled into a TAB file in `build/c_hello.tab`.

---
## Upload an application

You will need [tockloader](https://github.com/tock/tockloader).
  - display board information (apps, kernel etc)
  - install apps
  - delete apps

```bash
tock@tock:~/libtock-c/examples/c_hello$ tockloader 
[ERROR  ] Missing Command.

usage: tockloader [-h] [--debug] [--version]  ...

optional arguments:
  -h, --help         show this help message and exit
  --debug            Print additional debugging information
  --version          Print Tockloader version and exit

Commands:
  
    listen           Open a terminal to receive UART data
    install          Install apps on the board
    update           Update an existing app with this version
    uninstall        Remove an already flashed app
    list             List the apps installed on the board
    info             Verbose information about the connected board
    erase-apps       Delete apps from the board
    enable-app       Enable an app so the kernel runs it
    disable-app      Disable an app so it will not be started
    sticky-app       Make an app sticky so it is hard to erase
    unsticky-app     Make an app unsticky (the normal setting)
    flash            Flash binaries to the chip
    read             Read arbitrary flash memory
    write            Write arbitrary flash memory with constant value
    dump-flash-page  Read a page of flash from the board
    list-attributes  List attributes stored on the board
    set-attribute    Store attribute on the board
    remove-attribute
                     Remove attribute from the board
    set-start-address
                     Set bootloader jump address
    inspect-tab      Get details about a TAB
    list-known-boards
                     List the boards that Tockloader explicitly knows about
```

---

### Tockloader for microbit_v2

Tockloader uses `openocd` to read and write to the micro:bit v2. 

You have to add two parameters to the command line:
  - `--board microbit_v2`
  - `--openocd`

Parameters are placed after the command.

```bash
$ tockloader command --board microbit_v2 --openocd ...
```

---

### Tockloader examples

List applications

```bash
tock@tock:~/libtock-c/examples/c_hello$ tockloader list --board microbit_v2 --openocd[INFO   ] Using settings from KNOWN_BOARDS["microbit_v2"]
┌──────────────────────────────────────────────────┐
│ App 0                                            |
└──────────────────────────────────────────────────┘
  Name:                  c_hello
  Enabled:               True
  Sticky:                False
  Total Size in Flash:   2048 bytes


[INFO   ] Finished in 1.484 seconds
```

Install an application

```bash
tock@tock:~/libtock-c/examples/c_hello$ tockloader install --board microbit_v2 --openocd build/c_hello.tab 
[INFO   ] Using settings from KNOWN_BOARDS["microbit_v2"]
[STATUS ] Installing app on the board...
[INFO   ] Flashing app c_hello binary to board.
[INFO   ] Finished in 4.699 seconds
```

---

# Workpoint 3 .top_image[![Work In Progress](../images/work_in_progress.png)]

1. Upload the `c_hello` app.
2. Upload the `blink` app.
3. Use the process console to list the processes

---

# Workpoint 4 .top_image[![Work In Progress](../images/work_in_progress.png)]

Write and upload a new application that writes a message to the console using `printf`.

```c
#include <stdio.h>

int main (void)
{
    printf ("Application Message\n");
    return 0;
}
```

Hint: You can start by copying one of the existing applications.

---

# Workpoint 5 .top_image[![Work In Progress](../images/work_in_progress.png)]

1. Change the `blink` application so that:
    - it prints to the console the number of available LEDs
    - it lights up one LED at a time

2. Change the `button` application so that:
    - it prints the number of buttons available
    - it prints the name of the button (A or B) that was pressed

Hint: use `printf` to write to the console (just as you would use it normally)

---

# Workpoint 6 .top_image[![Work In Progress](../images/work_in_progress.png)]

Change the `button` application so that:
  - it prints on the LED matrix the name of the pressed button
  - waits a few seconds and stops printing

Hint: you will have to write your own small font for the A and B letters

---

# Workpoint 7 .top_image[![Work In Progress](../images/work_in_progress.png)]

1. Upload the sensors app and find out what sensors are available
2. Write your own weather station app the print in the console the sensor data once a second
3. Use the LED matrix to print the temperature

Hint: you will have to write your own small font for numbers

---
# Processes

One process is running at a time 

- __Running__ - the process is schedulable
- __Yielded__ - the process is waiting
- __Faulted__ - the process had a fault
  - Stop process
  - Restart process
  - Report fault
- __Terminated__ - the process has exited

.right[.card[.small[![Scheduler Card](../images/sep_scheduler.png)]]]


---

## Faults

The kernal and the processes can fault

.pre[
````terminal
panicked at 'Process c_hello had a fault', kernel/src/process_standard.rs:282:17
        Kernel version release-1.6-1393-gc4920c9ab

---| No debug queue found. You can set it with the DebugQueue component.

---| Cortex-M Fault Status |---
Data Access Violation:              true
Undefined Instruction Usage Fault:  true
Forced Hard Fault:                  true
Faulting Memory Address:            0x00000000
Fault Status Register (CFSR):       0x00010082
Hard Fault Status Register (HFSR):  0x40000000

---| App Status |---
𝐀𝐩𝐩: c_hello   -   [Faulted]
 Events Queued: 0   Syscall Count: 3   Dropped Upcall Count: 0
 Restart Count: 0
 Last Syscall: Some(Memop { operand: 11, arg0: 536889844 })


 ╔═══════════╤══════════════════════════════════════════╗
 ║  Address  │ Region Name    Used | Allocated (bytes)  ║
 ╚0x20006000═╪══════════════════════════════════════════╝
             │ ▼ Grant        1056 |   1056          
  0x20005BE0 ┼───────────────────────────────────────────
             │ Unused
  0x200049F4 ┼───────────────────────────────────────────
             │ ▲ Heap            0 |   4588               S
  0x200049F4 ┼─────────────────────────────────────────── R
             │ Data            500 |    500               A
  0x20004800 ┼─────────────────────────────────────────── M
             │ ▼ Stack        2048 |   2048          
  0x20004000 ┼───────────────────────────────────────────
             │ Unused
  0x20004000 ┴───────────────────────────────────────────
             .....
  0x00040400 ┬─────────────────────────────────────────── F
             │ App Flash       980                        L
  0x0004002C ┼─────────────────────────────────────────── A
             │ Protected        44                        S
  0x00040000 ┴─────────────────────────────────────────── H

  R0 : 0x0000088C    R6 : 0x0004002C
  R1 : 0x000402A4    R7 : 0x20004000
  R2 : 0x0000000A    R8 : 0x00000000
  R3 : 0x00000000    R10: 0x00000000
  R4 : 0x0004002C    R11: 0x00000000
  R5 : 0x00000000    R12: 0x7307FFE7
  R9 : 0x20004800 (Static Base Register)
  SP : 0x200047D8 (Process Stack Pointer)
  LR : 0x000400E3
  PC : 0x0004009C
 YPC : 0x00040086

 APSR: N 0 Z 1 C 1 V 0 Q 0
       GE 0 0 0 0
 EPSR: ICI.IT 0x00
       ThumbBit true 

 Total number of grant regions defined: 13
  Grant  0: --          Grant  5: --          Grant 10: --        
  Grant  1: --          Grant  6: --          Grant 11: --        
  Grant  2: --          Grant  7: --          Grant 12: --        
  Grant  3: --          Grant  8: --        
  Grant  4: --          Grant  9: --        

 Cortex-M MPU
  Region 0: [0x20004000:0x20006000], length: 8192 bytes; ReadWrite (0x3)
    Sub-region 0: [0x20004000:0x20004400], Enabled
    Sub-region 1: [0x20004400:0x20004800], Enabled
    Sub-region 2: [0x20004800:0x20004C00], Enabled
    Sub-region 3: [0x20004C00:0x20005000], Disabled
    Sub-region 4: [0x20005000:0x20005400], Disabled
    Sub-region 5: [0x20005400:0x20005800], Disabled
    Sub-region 6: [0x20005800:0x20005C00], Disabled
    Sub-region 7: [0x20005C00:0x20006000], Disabled
  Region 1: [0x00040000:0x00040400], length: 1024 bytes; UnprivilegedReadOnly (0x2)
    Sub-region 0: [0x00040000:0x00040080], Enabled
    Sub-region 1: [0x00040080:0x00040100], Enabled
    Sub-region 2: [0x00040100:0x00040180], Enabled
    Sub-region 3: [0x00040180:0x00040200], Enabled
    Sub-region 4: [0x00040200:0x00040280], Enabled
    Sub-region 5: [0x00040280:0x00040300], Enabled
    Sub-region 6: [0x00040300:0x00040380], Enabled
    Sub-region 7: [0x00040380:0x00040400], Enabled
  Region 2: Unused
  Region 3: Unused
  Region 4: Unused
  Region 5: Unused
  Region 6: Unused
  Region 7: Unused

To debug, run `make debug RAM_START=0x20004000 FLASH_INIT=0x40055`
in the app's folder and open the .lst file.


````]


---

class: split-50
## System Call

.column[
API provided by the OS
- ABI (Application Binary Interface)
- uses the `svc` (or similar) instruction

Applications request an action from the OS

.card[.small_vertical[![System Call](../images/sep_system_call.png)]]
]

.column[
.center[.splash_vertical[![Scheduler](../images/syscall.svg)]]
]

---
## Tock System Calls

0. Yield
1. Subscribe
2. Command
3. ReadWriteAllow
4. ReadOnlyAllow
5. Memop
6. Exit

.right[
.card[.small[![yield](../images/sep_yield.png)]]
.card[.small[![subscribe](../images/sep_subscribe.png)]]
.card[.small[![command](../images/sep_command.png)]]
.card[.small[![allow](../images/sep_allow.png)]]
.card[.small[![memop](../images/sep_memop.png)]]
.card[.small[![returncode](../images/sep_returncode.png)]]
]

---

### 0: Yield

Yield transitions the current process from the Running to the Yielded state.

```rust
// waits for the next upcall
// The process will not execute again until another upcall re-schedules the
// process.
yield()

// does not wait for the next upcall
// If a process has no enqueued upcalls, the
// process immediately re-enters the Running state.
yield_no_wait()
```

##### Return

_yield_: None 

_yield_no_wait_:
  - 1 - upcall ran
  - 0 - no upcall ran

---

### 1: Subscribe

Subscribe assigns upcall functions to be executed in response to various
events.
- a upcall function has a *upcall ID* (`driver`,`subscribe_number`), 

```rust
subscribe(driver: u32, subscribe_number: u32, upcall: u32, userdata: u32) -> Result<Upcall, (Upcall, ErrorCode)>
```

##### Arguments

 - `driver`: An integer specifying which driver to call.
 - `subscribe_number`: An integer index for which function is being subscribed.
 - `upcall`: A pointer to a upcall function to be executed when this event
 occurs. `void callback(int arg1, int arg2, int arg3, void* data)`.
 - `userdata`: A pointer to a value of any type that will be passed back

##### Return

- The previously registered upcall or TOCK_NULL_UPCALL
- Errors
 - `NODEVICE` if `driver` does not refer to a valid kernel driver.
 - `NOSUPPORT` if the driver exists but doesn't support the `subscribe_number`.
 - Other return codes based on the specific driver.

---

### 2: Command

Command instructs the driver to perform a specific action.

```rust
command(driver: u32, command_number: u32, argument1: u32, argument2: u32) -> CommandReturn
```

#### Arguments

 - `driver`: An integer specifying which driver to call.
 - `command_number`: An integer specifying the requested command.
 - `argument1`: A command-specific argument.
 - `argument2`: A command-specific argument.

- One Tock convention with the Command syscall is that command number 0 will
always return a value of 0 or greater if the driver is supported.

#### Return
- 3 usize numbers
- Errors
 - `NODEVICE` if `driver` does not refer to a valid kernel driver.
 - `NOSUPPORT` if the driver exists but doesn't support the `command_number`.
 - Other return codes based on the specific driver.

---

### 3 and 4: AllowRead(Write/Only)

Allow shares memory buffers between the kernel and application.
- null pointer revokes sharing a region.

```rust
allow_readwrite(driver: u32, allow_number: u32, pointer: usize, size: u32) -> Result<ReadWriteAppSlice, (ReadWriteAppSlice, ErrorCode)>
allow_readonly(driver: u32, allow_number: u32, pointer: usize, size: u32) -> Result<ReadWriteAppSlice, (ReadWriteAppSlice, ErrorCode)>
```

#### Arguments

 - `driver`: An integer specifying which driver should be granted access.
 - `allow_number`: A driver-specific integer specifying the purpose of this
   buffer.
 - `pointer`: A pointer to the start of the buffer in the process memory space.
 - `size`: An integer number of bytes specifying the length of the buffer.

#### Return
- The previous allowed pointer or NULL
- Errors
 - `NODEVICE` if `driver` does not refer to a valid kernel driver.
 - `NOSUPPORT` if the driver exists but doesn't support the `allow_number`.
 - `INVAL` the buffer referred to by `pointer` and `size` lies completely or
partially outside of the processes addressable RAM.
 - Other return codes based on the specific driver.

---

### 5: Memop

Memop expands the memory segment available to the process, allows the process to
retrieve pointers to its allocated memory space, provides a mechanism for
the process to tell the kernel where its stack and heap start, and other
operations involving process memory.

```rust
memop(op_type: u32, argument: u32) -> [[ VARIES ]] as u32
```

#### Arguments

 - `op_type`: An integer indicating whether this is a `brk` (0), a `sbrk` (1),
   or another memop call.
 - `argument`: The argument to `brk`, `sbrk`, or other call.

Each memop operation is specific and details of each call can be found in
the [memop syscall documentation](syscalls/memop.md).

#### Return

- Dependent on the particular memop call.

---

### 6: Exit

The process signals the kernel that it has no more work to do and can be stopped or that it asks
the kernel to restart it.

```rust
tock_exit(completion_code: u32)
tock_restart(completion_code: u32)
```

##### Return

None 

---
## Workpoint 8 .top_image[![Work In Progress](../images/work_in_progress.png)]

Enable the system calls trace in `kernel/src/config.rs`. 
1. Upload an app that prints a text on the shell using `printf`. 
  - How many system calls is printf using?
  - What is the driver number of the driver used for printing?

2. Upload the blink app and look at the system calls trace.
  - What is the leds matrix's driver number?

---

## Workpoint 9 .top_image[![Work In Progress](../images/work_in_progress.png)]

1. Write and upload and app that faults.
```c
int main(void)
{
      int *s = NULL;
      *s = 0;
      return 0;
}
```

2. Modify the app fault policy so that it does not panic when an app faults
  - hint: `main.rs` serach for `FAULT_RESPONSE`.

---
# Hello Driver

Kernel

1. Write the `Hello` structure and its implementation
2. Implement the `Driver` trait for `Hello`
  - all methiods have default implementation
3. Add the driver to the board structure in `main.rs`

User space

- Implement the system calls

---
## Kernel

Write the driver and implement the `Driver` trait (1 and 2).

Write a file `hello.rs` in the same folder as `main.rs`.

```rust
use kernel::{Driver, ProcessId, CommandReturn, ErrorCode};

/// Each driver is identified by a unique number
///
/// numbers higher than 0xa0000000 are unused by standard drivers
pub const DRIVER_NUM: usize = 0xa0000000;

/// The Hello structure
pub struct Hello {}


/// The hello implementation
impl Hello {
    pub fn new() -> Hello {
        Hello {}
    }
}

/// The driver system calls implementation
impl Driver for Hello {
    /// subscribe and allow will use the default implementation

    /// command syscall
    fn command(&self, which: usize, r2: usize, r3: usize, caller_id: ProcessId) -> CommandReturn {
        match command_num {
            // command_num 0 is used to verify if the driver exists
            0 => CommandReturn::success(),

            // the command number is not defined
            _ => CommandReturn::failure (ErrorCode::NOSUPPORT),
        }
    }
}
```

---
### Kernel

Register the driver for in the board's structure (3)

In `main.rs` 

```rust
/// use the driver module
mod hello;

// ...
/// Supported drivers by the platform
pub struct Platform {
    ble_radio: &'static capsules::ble_advertising_driver::BLE<
        'static,
        nrf52::ble_radio::Radio<'static>,
        capsules::virtual_alarm::VirtualMuxAlarm<'static, nrf52::rtc::Rtc<'static>>,
    >,
    console: &'static capsules::console::Console<'static>,
    gpio: &'static capsules::gpio::GPIO<'static, nrf52::gpio::GPIOPin<'static>>,
    led: &'static capsules::led_matrix::LedMatrixDriver<
        'static,
        nrf52::gpio::GPIOPin<'static>,
        capsules::virtual_alarm::VirtualMuxAlarm<'static, nrf52::rtc::Rtc<'static>>,
    >,
    button: &'static capsules::button::Button<'static, nrf52::gpio::GPIOPin<'static>>,
    rng: &'static capsules::rng::RngDriver<'static>,
    ninedof: &'static capsules::ninedof::NineDof<'static>,
    lsm303agr: &'static capsules::lsm303agr::Lsm303agrI2C<'static>,
    temperature: &'static capsules::temperature::TemperatureSensor<'static>,
    ipc: kernel::ipc::IPC<NUM_PROCS>,
    adc: &'static capsules::adc::AdcVirtualized<'static>,
    alarm: &'static capsules::alarm::AlarmDriver<
        'static,
        capsules::virtual_alarm::VirtualMuxAlarm<'static, nrf52::rtc::Rtc<'static>>,
    >,
    buzzer: &'static capsules::buzzer_driver::Buzzer<
        'static,
        capsules::virtual_alarm::VirtualMuxAlarm<'static, nrf52833::rtc::Rtc<'static>>,
    >,
    app_flash: &'static capsules::app_flash_driver::AppFlash<'static>,
    sound_pressure: &'static capsules::sound_pressure::SoundPressureSensor<'static>,
    // hello driver
    hello: &'static hello::Hello
}
// ...

/// Mapping of integer syscalls to objects that implement syscalls.
impl kernel::Platform for Platform {
  fn with_driver<F, R>(&self, driver_num: usize, f: F) -> R
  where
      F: FnOnce(Option<&dyn kernel::Driver>) -> R,
  {
      match driver_num {
          capsules::console::DRIVER_NUM => f(Some(self.console)),
          capsules::gpio::DRIVER_NUM => f(Some(self.gpio)),
          capsules::alarm::DRIVER_NUM => f(Some(self.alarm)),
          capsules::button::DRIVER_NUM => f(Some(self.button)),
          capsules::led_matrix::DRIVER_NUM => f(Some(self.led)),
          capsules::ninedof::DRIVER_NUM => f(Some(self.ninedof)),
          capsules::adc::DRIVER_NUM => f(Some(self.adc)),
          capsules::temperature::DRIVER_NUM => f(Some(self.temperature)),
          capsules::lsm303agr::DRIVER_NUM => f(Some(self.lsm303agr)),
          capsules::rng::DRIVER_NUM => f(Some(self.rng)),
          capsules::ble_advertising_driver::DRIVER_NUM => f(Some(self.ble_radio)),
          capsules::buzzer_driver::DRIVER_NUM => f(Some(self.buzzer)),
          capsules::app_flash_driver::DRIVER_NUM => f(Some(self.app_flash)),
          capsules::sound_pressure::DRIVER_NUM => f(Some(self.sound_pressure)),
          kernel::ipc::DRIVER_NUM => f(Some(&self.ipc)),
          // hello driver
          hello::DRIVER_NUM => f(Some(self.hello)),
          _ => f(None),
      }
  }
}
// ...

/// Main function called after RAM initialized.
#[no_mangle]
pub unsafe fn main() {
    // ...

    /// Create a new instance of type Hello using Hello::new ()
    let hello = static_init! (hello::Hello, hello::Hello::new());

    /// Create a new instance of the board's structure
    let platform = Platform {
      ble_radio: ble_radio,
      console: console,
      gpio: gpio,
      button: button,
      led: led,
      rng: rng,
      temperature: temperature,
      lsm303agr: lsm303agr,
      ninedof: ninedof,
      buzzer: buzzer,
      sound_pressure: sound_pressure,
      adc: adc_syscall,
      alarm: alarm,
      app_flash: app_flash,
      ipc: kernel::ipc::IPC::new(board_kernel, &memory_allocation_capability),
      // the hello driver
      hello: hello,
  }
    // ...
}
```

---
## User space

In your application's folder

hello.h
```c
#pargma once

#define HELLO_DRIVER_NUMBER 0xa0000000

bool hello_is_available (void);

```

hello.c
```c
#include "hello.h"
#include <tock.h>

bool hello_is_available (void) {
    syscall_return_t command_return = command(HELLO_DRIVER_NUMBER, 0, 0, 0);
    if (command_return.type == TOCK_SYSCALL_SUCCESS) {
        return true;
    } else {
        return false;
    }
}
```

---
## Workpoint 10 .top_image[![Work In Progress](../images/work_in_progress.png)]

Add `command_num` 1 to the driver and print a text on the shell when it is called.

```rust
/// The driver system calls implementation
impl Driver for Hello {
    /// subscribe and allow will use the default implementation

    /// command syscall
    fn command(&self, which: usize, r2: usize, r3: usize, caller_id: ProcessId) -> CommandReturn {
      match command_num {
          // command_num 0 is used to verify if the driver exists
          0 => CommandReturn::success(),
          1 => // ...

          // the command number is not defined
          _ => CommandReturn::failure (ErrorCode::NOSUPPORT),
      }
  }
}
```

Add a function for it in the header and source file in userspace. 
Write and upload an app that userspace the driver.

---
# Mutability

All Tock traits use `&self` to be able to share a driver with several other drivers.

Interior mutability:
- Cell<T> (`core::cell::Cell`)
- OptionalCell<T> (`kernel::common:cells::OptionalCell`)
- TakeCell<T> (`kernel::common::cells::TakeCell`)

.right[
.card[.small_vertical[![Cell](../images/sep_cell.png)]]
.card[.small_vertical[![OptionalCell](../images/sep_optionalcell.png)]]
.card[.small_vertical[![TakeCell](../images/sep_takecell.png)]]
]

---
## Workpoint 11 .top_image[![Work In Progress](../images/work_in_progress.png)]

Add `command_num` 2 that will increment a counter and return it to the app.
  Hint: use `CommandReturn::success_u32 (...)`

Each time the app calls the system call, the driver will will return an incremented number.

```c
#include "hello.c"
#include <stdio.h>
#include <timer.h>

int nr;

int main(void) {
    while (true) {
        nr = hello_counter ();
        printf ("Counter %d\n", n);
        delay_ms (1000);
    }
}
```

Hint: store the current number in the `Hello` structure.

---
# Homework .top_image[![Work In Progress](../images/work_in_progress.png)]

Work in teams

- Write a driver that exposes thew following commands:
  1. Set the latitude and longitude parameters
  2. Set the acceleration value
  3. Set the temperature value
  4. Set the sound value
  5. Print in JSON format all the values to the console
  6. Print in XML format all the values to the console

- Write a software in any language you want that reads the JSON or XML from the console and sends it
to an MQTT broker. You may use the free version of [HiveMQ](https://www.hivemq.com/mqtt-cloud-broker).

- Use [Node-Red](https://nodered.org/) ([Frontend for Node-Red](https://fred.sensetecnic.com/) provides a free hosted version) to read the data from the MQTT broker and plot it on a world map.
Hint: use the `WorldMap` node.

    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js">
    </script>
    <script src="../script/playground.js">
    </script>
    <script>
      var slideshow = remark.create({
		navigation: {
				scroll: false
			}
    });
    window.cPlaygroundUrl = "https://cplayground.com/";
    window.playgroundUrl = "https://play.rust-lang.org/";
    </script>
  </body>
</html>